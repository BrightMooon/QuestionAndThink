# 一 种类
## 1. 满二叉树
### 1.1 节点个数
    深度为3，就是3层，节点个数为 2^k -1 

## 2. 完全二叉树
### 2.1 除了底层元素，其他层都是满的
### 2.2 底层的元素，从左到右都是连续的

## 3. 二叉搜索树
### 3.1 顺序
    左子树的所有节点都小于中间节点，右子树的所有节点都大于中间节点
### 3.2 时间复杂度
    查询logN

## 4. 平衡二叉搜索树
### 4.1 平衡？
    整个或者局部，每一个左子树和右子树的高度差不能超过1
### 4.2 时间复杂度
    插入和查询 都是 logN



# 二 存储方式

# 三 遍历 (两大类/四小类)
## 深度优先搜索（一个方向走到黑，再回头走另一个方向）
//通常用递归实现

+ 前序遍历（根左右）

+ 中序遍历 （左根右）

+ 后序遍历 （左右根）

## 广度优先搜索
+ 层序遍历
//  队列迭代实现

# 四 定义 （要求可以正确的手写）
```
type TreeNode struct{
    val int
    left *TreeNode
    right *TreeNode 
}
&TreeNode{1,*left,*right}
```

# 五 属性
## 高度
从叶子节点到当前节点的距离
从下往上

## 深度
从根节点要当前节点的距离，根节点从1开始计数
从上往下

# 六 b+树













