# 一 种类
## 1. 满二叉树
### 1.1 节点个数
    深度为3，就是3层，节点个数为 2^k -1 

## 2. 完全二叉树
### 2.1 除了底层元素，其他层都是满的
### 2.2 底层的元素，从左到右都是连续的

## 3. 二叉搜索树
### 3.1 顺序
    左子树的所有节点都小于中间节点，右子树的所有节点都大于中间节点
### 3.2 时间复杂度
    查询logN

## 4. 平衡二叉搜索树
### 4.1 平衡？
    整个或者局部，每一个左子树和右子树的高度差不能超过1
### 4.2 时间复杂度
    插入和查询 都是 logN



# 二 存储方式

# 三 遍历 (两大类/四小类)
## 遍历的直观理解
// https://blog.csdn.net/weixin_45525272/article/details/105837185

## 深度优先搜索（一个方向走到黑，再回头走另一个方向）
//通常用递归实现

+ 前序遍历（根左右）
先序遍历可以想象成，小仙儿从树根开始绕着整棵树的外围转一圈，经过结点的顺序就是先序遍历的顺序

+ 中序遍历 （左根右）
中序遍历可以想象成，按树画好的左右位置投影下来就可以了

+ 后序遍历 （左右根）
后序遍历就像是剪葡萄，我们要把一串葡萄剪成一颗一颗的。
还记得我们先序遍历绕圈的路线么？
就是围着树的外围绕一圈，如果发现一剪刀就能剪下的葡萄（必须是一颗葡萄），就把它剪下来，组成的就是后序遍历了。

## 深入理解三种遍历-大禹治水三过家门
+ 
来，让我们先把所有空结点都补上。
还记得我们先序和后序遍历时候跑的顺序么？按照这个顺序再跑一次，就是围着树的外围跑一整圈。
+ 
让我们来理解一下绕着外围跑一整圈的真正含义是：遍历所有结点时，都先往左孩子走，再往右孩子走。
观察一下，你有什么发现？
有没有发现，除了根结点和空结点，其他所有结点都有三个箭头指向它。
一个是从它的父节点指向它，一个是从它的左孩子指向它，一个是从它的右孩子指向它。
一个结点有三个箭头指向它，说明每个结点都被经过了三遍。一遍是从它的父节点来的时候，一遍是从它的左孩子返回时，一遍是从它的右孩子返回时。

+ 其实我们在用递归算法实现二叉树的遍历的时候，不管是先序中序还是后序，程序都是按照上面那个顺序跑遍所有结点的。

+ 先序中序和后序唯一的不同就是，在经过结点的三次中，哪次访问（输出或者打印或者做其他操作）了这个结点。有点像大禹治水三过家门，他会选择一次进去。
+ 
先序遍历顾名思义，就是在第一次经过这个结点的时候访问了它。就是从父节点来的这个箭头的时候，访问了它。
中序遍历也和名字一样，就是在第二次经过这个结点的时候访问了它。就是从左孩子返回的这个箭头的时候，访问了它。
后序遍历，就是在第三次经过这个结点的时候访问了它。就是从右孩子返回的这个箭头的时候，访问了它。

+ 其实不管是前序中序还是后序，在程序里跑的时候都是按照同样的顺序跑的，每个结点经过三遍，第几遍访问这个结点了，就叫什么序遍历。

## 广度优先搜索
+ 层序遍历
//  队列迭代实现

# 四 定义 （要求可以正确的手写）
```
type TreeNode struct{
    val int
    left *TreeNode
    right *TreeNode 
}
&TreeNode{1,*left,*right}
```

# 五 属性
## 高度
从叶子节点到当前节点的距离
从下往上

## 深度
从根节点要当前节点的距离，根节点从1开始计数
从上往下

# 六 b+树













